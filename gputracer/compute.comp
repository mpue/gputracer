#version 450

#define MAX_SPHERES 100
#define MAX_LIGHTS 10

struct Sphere {
  vec3 position;
  float radius;
  vec3 color;
  vec3 normal;
};

struct Light {
  vec3 position;
  vec3 color;
};

struct Ray {
  vec3 origin;
  vec3 direction;
};

struct HitRecord {
  vec3 pos;
  vec3 normal;
  float distance;
  bool hit;
};

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba8, binding = 0) uniform image2D outputImage;

layout(binding = 1) uniform FragUBO {
  mat4 invProjectionView;
  float near;
  float far;
}
ubo;

uniform Sphere spheres[MAX_SPHERES];
uniform int numSpheres;

uniform Light lights[MAX_LIGHTS];
uniform int numLights;

uniform float specStrength;
uniform float exponent;

vec3 ambient = vec3(0.2, 0.2, 0.2);

vec3 phong(Light light, HitRecord r, vec4 camPos, vec3 objectColor) {

    vec3 n =  r.normal;
	vec3 s = normalize( light.position - r.pos );
	vec3 v = normalize( camPos.xyz - r.pos);
	vec3 refl = reflect( -s, n );

	ambient *= 0.5;
	
	float sDotN = max( dot( s, n ), 0.0 );
	vec3 diffuse = vec3(0.5) * 0.7 * sDotN;
	
	float spec = specStrength * pow( max( dot(refl,v) , 0.0 ), exponent ); 

    vec3 result = (ambient + diffuse + spec) * objectColor;

    return result;
}


HitRecord raySphereIntersect(Ray ray,Sphere sphere) {

    HitRecord r;

    vec3 sphereToRay = ray.origin - sphere.position;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(sphereToRay, ray.direction);
    float c = dot(sphereToRay, sphereToRay) - sphere.radius * sphere.radius;
    float discriminant = b * b - 4.0 * a * c;
    if (discriminant >= 0) {
      float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
      float t2 = (-b + sqrt(discriminant)) / (2.0 * a);
      float t = (t1 > 0.0 && t1 < t2) ? t1 : t2;
      if (t > 0.0 && t2 > 0.0) { // Ensure t is positive

        vec3 hitPos = ray.origin + ray.direction * t;
        // Calculate the normal at the hit position
        vec3 hitNormal = normalize(hitPos - sphere.position);

        r.pos = hitPos;
        r.normal = hitNormal;
        r.hit = true;                
        r.distance = t;
        return r;
      }
    }

    r.hit  = false;
    return r;
}

void main() {

  ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
  ivec2 dims = imageSize(outputImage); // fetch image dimensions

  vec2 texCoord = vec2(float(pixelCoords.x) / float(dims.x),
                       float(pixelCoords.y) / float(dims.y));

  //  Normalized Device Coordinates (NDC)
  vec2 ndc = (2.0 * texCoord - 1.0);
  float ndcDepth = ubo.far - ubo.near;
  float ndcSum = ubo.far + ubo.near;

  //  World Space Ray
  vec4 camRay = ubo.invProjectionView * vec4(ndc * ndcDepth, ndcSum, ndcDepth);
  vec4 camOrigin = ubo.invProjectionView * vec4(ndc, -1.0, 1.0);

  //  Test ray with scene...
  Ray ray;
  ray.origin = camOrigin.xyz;
  ray.direction = normalize(camRay).xyz;
  
  vec3 outColor = vec3(0);

  HitRecord r;
  r.distance = 100000000.0;

  int k = 0;

  for (int i = 0; i < numSpheres; i++) {
      
    vec3 color = vec3(0.0, 0.0, 0.0);
    Sphere sphere = spheres[i];
    
    HitRecord tr = raySphereIntersect(ray,sphere);

    if (tr.hit) {
        if (tr.distance < r.distance) {
            r = tr;
            k = i;
        }
    }

  }
    
  float shadow = 1.0;

  HitRecord str;
  str.distance = 100000000.0;

if(r.hit) {
    for (int j = 0; j < numLights; j++) {
        vec3 lightDir = normalize(lights[j].position - r.pos);
        Ray shadowRay;
        shadowRay.origin = r.pos + 0.001 * lightDir; // Slightly offset to avoid self-intersection
        shadowRay.direction = lightDir;
        bool inShadow = false;

        for (int n = 0; n < numSpheres; n++) {
            if (n != k) { // Avoid self-intersection
                HitRecord temp = raySphereIntersect(shadowRay, spheres[n]);
                if (temp.hit && temp.distance < length(lights[j].position - r.pos)) {
                    inShadow = true;
                    break;
                }
            }
        }

        float shadowFactor = inShadow ? .1 : 1.0;
        outColor += shadowFactor * phong(lights[j], r, camOrigin, spheres[k].color);
    }
  }
  imageStore(outputImage, pixelCoords, vec4(outColor, 1.0));
}
